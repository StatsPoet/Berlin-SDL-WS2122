---
title: "exc22"
author: "Tobias_R"
date: "13 Januar 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Info about packages:
- geor: easiest package for fitting kriging models in r
- INLA: currently most used but more advanced. More complex notation
- gstat: less intuitive. You have to specifie everything over variagram

```{r}
###############
# Exercise 18 #
###############
rm(list = ls())

# Load package
library("geoR")

# #### define correlation functions ####
# for visualization of results
powered_exponential <- function(h, phi, kappa = 1) {
  return(exp(-(h / phi) ^ kappa))
}
exponential <- function(h, phi) {
  return(powered_exponential(h, phi, 1))
}

#### (i) load data and create geodata object ####
# Load data

schweiz <- read.table("spatial_data/Switzerland_new.dat", header = T)
#border  <- read.table("Switzerland.border.dat", header = T)

#??as.geodata

head(schweiz)

# Create geodata object #
schweiz_geodata_full <- as.geodata(schweiz, 2:3, 4)
# args for geodata:   object which is a table here. 
#                     the columns in the table where the spatial oordinates are
#                     the column where the data is



plot(schweiz_geodata_full)
# when using georR and saving the output from as.geodata, the plot function plots several graphs
# first plot shows where more or less rain fell. So takes the values of the data into account
# second graph / third graph: y/x coord versus the data
# fourth graph: distribution of the data
plot(schweiz_geodata_full, trend = "1st")
# There is a clear trend in the original data set. 
# With the 1st trend removed, there still appears to be a trend between the x coordinate 
# and residuals graph. Clustering appears to be visible on both graphs, so the next step 
# is removing the 2nd trend. 
plot(schweiz_geodata_full, trend = "2nd")
# When this is done, the clustering remains slightly present, 
# but the linear relationship is gone.
# more notes on trend on solution to exc sheet
# very useful tool
v <- variog(schweiz_geodata_full, max.dist = 450)
#interpretation of variogram in general on solution sheet
# here the range and the sill is not determined analytically but simply approximated by looking at the plot. One can see why. The plot already gives a good view on where the range would be
# the range of the whole domain is at around 200. range at around 60. So we can assume a usefull correlation in space, assume a spatial model
plot(v)

library("ggplot2")
# clear spatial pattern
ggplot() + geom_point(aes(xcoord, ycoord, colour = rain), data = schweiz) + 
  scale_colour_viridis_c()


```

```{r}
# (ii) Normal responses
# look at data
hist(schweiz$rain)

#transform with sqrt
schweiz_sqr <- schweiz
schweiz_sqr$rain <- sqrt(schweiz$rain)

#looks better, more normal
hist(schweiz_sqr$rain)

schweiz_geodata_full_sqr <- as.geodata(schweiz_sqr, 2:3, 4)

plot(schweiz_geodata_full_sqr)
plot(schweiz_geodata_full_sqr, trend = "1st")
plot(schweiz_geodata_full_sqr, trend = "2nd")

schweiz$rain <- sqrt(schweiz$rain)


```


```{r}
# (iii) subsample (n=100)
set.seed(0)
indices <- sample(1:nrow(schweiz), 100, replace = F)            
schweiz_geodata <- as.geodata(schweiz[indices, ], 2:3, 4)

par(mfrow=c(1,1))
plot(border, type="l")
points(schweiz$xcoord, schweiz$ycoord, cex=schweiz$rain/200)
points(schweiz_geodata$coords, col = 2, cex = schweiz_geodata$data/200)


#### Estimation of covariance structure ####
# ML
cov_est1 <- likfit(
  geodata = schweiz_geodata,
  cov.model = "exponential",
  ini.cov.pars = c(1, 1),
  nugget = 0,
  fix.nugget = FALSE,
  messages = TRUE
)

#likfit function to fit spatial model with ordianry kriging
# cov.model: in this class we always assume a exponential cov.model
# ini.cov.pars is the starting value
# nugget is the starting value for the nugget
# fix.nugget is wheather to fix the non-spatial error term. 
# default is the ML so no need to specify the schÃ¤tzer here
summary(cov_est1)
# gives sill
# effective range
# nugget = 0 is not relevant


# REML restricted maximum likleyhood
cov_est2 <- likfit(
  schweiz_geodata,
  cov.model="exponential",
  ini.cov.pars=c(1,1),
  nugget = 0,
  fix.nugget = FALSE,
  lik.method = "REML", # which specifies reml
  messages = FALSE
)
# larger range than before
# AIC is lower so reml is better
summary(cov_est2)

# Compare estimated correlation structure
h <- seq(0, 150, length = 500)
par(mfrow = c(1, 1))
plot(h, exponential(h, phi = cov_est1$phi), 
     type="l", ylim=c(0, 1), 
     ylab="Correlation", 
     main="Comparison of the estimated correlation functions")
lines(h, exponential(h, phi = cov_est2$phi), col = 2)
legend("topright", c("ML","REML"), col = c(1, 2), lty = c(1, 1))
#so cov_est$phi gives ou the correlation structue
```

```{r}
#### (iv)  Kriging with estimated correlation structure (fixed) ####

# Define grid for the location of predictions via function expand.grid
# choose fine grid for smoother surface of the predictions
prediction <- expand.grid(
  seq(floor(min(schweiz$xcoord)), ceiling(max(schweiz$xcoord)), by = 2),
  seq(floor(min(schweiz$ycoord)), ceiling(max(schweiz$ycoord)), by = 2)
)


head(prediction)
# Create objects of class krige.control and use them for Kriging
# type.krige="ok" for "ordinary kriging"
# obj.model: List of model parameters (Here: Output of function likfit)

# ML

#setup model ordinary kriging model
krig_control1 <- krige.control(
  type.krige="ok", 
  obj.model = cov_est1
  )


krig_est1 <- krige.conv(
  schweiz_geodata,
  locations = prediction,
  borders = border,
  krige = krig_control1
  ) 

# same for REML
krig_control2 <- krige.control(type.krige="ok", obj.model = cov_est2)
krig_est2 <- krige.conv(schweiz_geodata, 
                        locations = prediction, 
                        borders = border, 
                        krige = krig_control2)

#### (iv) Plot results ####
par(mfrow=c(1,2))
image(krig_est1, main="ML")    
image(krig_est2, main="REML")    
# slightly larger range for REML
```

```{r}
#### (v) ### Estimate models with anisotropy
cov_est13 <- likfit(schweiz_geodata, 
                    cov.model = "exponential", 
                    ini.cov.pars = c(1,1), 
                    fix.psiA = F, # psiA from shiny is not fixed anymore
                    fix.psiR = F, # psiR from shiny is not fixed anymore
                    lik.method = "REML",
                    message = F)
summary(cov_est13) # no the model fits the angle and ratio of anisotropy
krig_control13 <- krige.control(type.krige="ok", obj.model = cov_est13)
krig_est13 <- krige.conv(schweiz_geodata, 
                         locations = prediction, 
                         borders = border, 
                         krige = krig_control13)

# Visualisation of estimated anisotropy correlation functions
# par(mfrow = c(1, 2))
# 
# x <- seq(-7, 7, length = 151)
# y <- seq(-7, 7, length = 151)
# coords <- as.matrix(expand.grid(x, y))
# 
# # Plot correlation structure
# corr <- exp(-norm)
# corr <- matrix(corr, ncol = 151, nrow = 151)
# par(mfrow=c(1,1))
# contour(
#   x,
#   y,
#   corr,
#   axes = T,
#   xlab = "",
#   ylab = "",
#   main = "REML anisotropy",
#   xlim = c(-7, 7),
#   ylim = c(-7, 7)
# )
# 
# # Estimated Effects
# summary(cov_est1)
# summary(cov_est13)

# Compare Kriging estimators
par(mfrow=c(1,2))
#image(krig_est1 , main=" Isotropy, ML ")       
image(krig_est2 , main=" Isotropy, REML ")
image(krig_est13 , main=" Anisotropy, REML ")
```

